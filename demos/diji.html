<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Dijikistra </title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
        <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
        
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
        <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet">
        
        <link rel="stylesheet" href="../css/main.css">
        <link rel="stylesheet" href="../css/insertion.css">
        <link rel="stylesheet" href="diji.css">
    </head>
    <body>
    
        <nav class="navbar">
            <ul class="slidebar">
                <li onclick=hideSidebar()><a href="#"><svg xmlns="http://www.w3.org/2000/svg" height="26" viewBox="0 96 960 960" width="26"><path d="m249 849-42-42 231-231-231-231 42-42 231 231 231-231 42 42-231 231 231 231-42 42-231-231-231 231Z"/></svg></a></li>
                <li> <h4 class="about"><a href="about.html">About</a></h4></li>
                <li> <h4 class="help"><a href="#Help">Help</a></h4></li>
                <li> <div class="algocode" ><h4>AlgoCode</h4></div></li>
            </ul>
            <div class="section1" onclick="window.location.href='index.html'" style="cursor: pointer;"><h4>ALGOVERSE</h4></div>
            <div class="section2">
               <li> <h4 class="about"><a href="about.html">About</a></h4></li>
               <li> <h4 class="help"><a href="#Help">Help</a></h4></li>
               <li  style="border:none;" > <div class="algocode" style="border:none;"><h4>AlgoCode</h4></div></li>
               <li class="menu-button" onclick=showSidebar()><svg xmlns="http://www.w3.org/2000/svg" height="26" viewBox="0 96 960 960" width="26"><path d="M120 816v-60h720v60H120Zm0-210v-60h720v60H120Zm0-210v-60h720v60H120Z" fill="#fff" /></svg></li>
            </div>
        </nav>
        
        <div id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>Dijikistra</h3>
                <button class="close-btn" onclick="closeSidebar()" ><span class="material-symbols-outlined" id="close">
                    close
                    </span></button>
            </div>
            <ul>
                <li class="has-submenu">
                    <a href="javascript:void(0);" onclick="toggleSubmenu1()" class="menu-title">
                        Description &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <i class="fa-solid fa-angle-down arrow-icon"></i>
                    </a>
                    <div class="submenu" id="submenu1">
                        <div class="step-indicator">
                            <div class="step" id="step1">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#Theory" class="sidebar-link">Theory</a></div>
                            </div>
                            <div class="step" id="step2">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#Advantages" class="sidebar-link">Advantages</a></div>
                            </div>
                            <div class="step" id="step3">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#Disadvantages" class="sidebar-link">Disadvantages</a></div>
                            </div>
                            <div class="step" id="step4">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#Applications" class="sidebar-link">Applications</a></div>
                            </div>
                        </div>
                    </div>
                </li>
                
                
                <li class="has-submenu">
                    <a href="javascript:void(0);" onclick="toggleSubmenu2()">Algorithm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <i class="fa-solid fa-angle-down arrow-icon2" ></i>
                    </a>
                    <ul class="submenu" id="submenu2">
                        <div class="step-indicator2">
                            <div class="step" id="step1">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#pseudocode">Pseudocode</a></div>
                            </div>
                            <div class="step" id="step2">
                                <div class="circle"><i class="fas fa-check"></i></div>
                                <div class="line"></div>
                                <div class="word"><a href="#flowchart">Flowchart</a></div>
                            </div>
                            
                        </div>
                    </ul>
                </li>
                
                <li><a href="#Visualization">Visualization</a></li>
                <li><a href="#tcomplexity" >Time complexity</a></li>
                <li><a href="#scomplexity" >Space Complexity</a></li>
            </ul>
        </div>
        
    
        <button class="menu-btn" onclick="openSidebar()"><span class="material-symbols-outlined" style="color:#fff;">
            dock_to_left
            </span></button>

            <div class="content">
                <div id="Theory" class="content-container">
                    
                     <div class="article-title">
                       <h1>Dijikistra algorithm</h1>
                    </div>
                    <br>
                    <hr>
                    <br>
                    <div class="text" style="height: auto; overflow: hidden;">
                        <p dir="ltr" style="text-align: justify;">
        
                           <b>Dijikistra Algorithm:</b> Dijkstra's Algorithm is a graph search algorithm used to find the shortest path between a source node and all other<br><br> nodes in a weighted graph. It guarantees the shortest path for graphs with non-negative edge weights. <br><br>The algorithm is commonly used in network routing, GPS navigation, and solving pathfinding problems.
                           <br><br>

                        
                        <p dir="ltr" style="text-align: justify;">
                            <h2>HOW IT WORKS?</h2>
                           
                            <ol>
                               
                              
                                <li><strong>Initialization:</strong><br><br>
                                    &nbsp; &nbsp;Assign a tentative distance value of infinity (∞) to every node except the starting node, which gets a distance of 0.<br><br>
                                    &nbsp; &nbsp; Mark all nodes as unvisited. Set the starting node as the current node. <br><br>
                                    

                                </li>
                                <li><strong>Processing the Current Node:</strong><br><br>
                                    &nbsp; &nbsp; For the current node, examine all its unvisited neighbors.
                                    <br><br>
                                    &nbsp; &nbsp; Calculate the tentative distance to each neighbor as <br><br>
                                    &nbsp; &nbsp; &nbsp; &nbsp;tentative distance=distance to current node+edge weight to neighbor<br><br> 
                                    &nbsp; &nbsp; If the calculated distance is smaller than the known distance, update the tentative distance of the neighbor.
                                    <br><br>
                                </li>
                                <li><strong>Mark Node as Visited:</strong><br><br> 
                                    &nbsp; &nbsp; Once all neighbors of the current node are processed, mark the current node as visited. A visited node will not be checked again.
                                    <br><br>
                                </li>
                                <li><strong>Select the Next Node:</strong><br><br> 
                                    &nbsp; &nbsp; From the unvisited nodes, choose the one with the smallest tentative distance as the new current node.
                                    <br><br>
                                </li>
                                <li><strong>Repeat:</strong><br><br> 
                                    &nbsp; &nbsp; Repeat steps 2–4 until all nodes are visited or the shortest distance to the desired destination is determined.
                                    <br><br>
                                </li>
                                <li><strong>Output:</strong><br><br> 
                                    &nbsp; &nbsp;The shortest distances from the source to all other nodes are stored, and the algorithm terminates.
                                    <br><br>
                                </li>
                                
                            </ol>
                            
                            
                        </div>
                    </div>
        
        <!-- advantages -->
        
                <div id="Advantages" class="content-container">
                    <div class="article-title text">
                        <h1>Advantages</h1>
                     </div>
                     <br>
                     <hr>
                     <br><br>
                    <div class="article-title text">
                        
                            <ol>
                               
                                    <ul>
                                        <li><strong>Guaranteed Optimal Solution:</strong> Always finds the shortest path for graphs with non-negative edge weights.</li>
                                   <br><br>
                               
                                
                                        <li><strong>Widely Applicable:</strong>Suitable for routing and navigation systems, such as GPS, computer networks, and game development.</li><br><br>
                                
                                        <li><strong>Efficient for Sparse Graphs:</strong>When implemented with a priority queue (e.g., a min-heap), its time complexity is O((V+E)logV), where  V is the number of vertices and  E is the number of edges.
                                            </li>
                                    <br><br>
                               
                                   
                                        <li><strong>Handles Multiple Destinations:</strong> It computes the shortest paths from a single source to all other nodes, making it useful for applications where multiple destinations need to be considered.

        
                                        </li>
                                   <br><br>
                                
                                   <li><strong>Straightforward Implementation:</strong> The algorithm is conceptually simple and can be easily implemented.

                                    
                                   </li>
                                   <br><br>
                                  
                                </ul>
                            </ol>
                        
                        
                     </div>
        
                </div>
        
        
        <!-- disadvantages -->
        
        
                <div id="Disadvantages" class="content-container">
                    <div class="article-title text">
                        <h1>Disadvantages</h1>
                     </div>
                     <br>
                     <hr>
                     <br><br>
                    <div class="article-title text">
                        <ol>
                            <ul>
                                <li><strong>Non-Negative Edge Weight Restriction:</strong>Cannot handle graphs with negative edge weights (e.g., it fails to work correctly with certain types of graphs where Bellman-Ford is more appropriate).</li>
                           <br><br>
                       
                        
                                <li><strong>High Complexity for Dense Graphs:</strong>In dense graphs with a large number of edges, the algorithm's efficiency can degrade due to the need to process every edge.
        
                                </li><br><br>
                        
                                <li><strong>Inefficiency with Large Graphs:</strong>For very large graphs, the memory and processing requirements can be significant, especially without optimized data structures.
                                </li>
                            <br><br>
                       
                           
                                <li><strong>Single Source Limitation:</strong>It only solves the shortest-path problem from one source at a time. For multiple sources, it must be run repeatedly.
        
                                </li>
                           <br><br>
                        
                           <li><strong>Not Dynamic:</strong>If the graph changes (e.g., edges are added or removed), the algorithm needs to be rerun from scratch.
                           </li>
                           <br><br>
                           
                        </li>
                        </ul>
                        </ol>
                    
                     </div>
        
                </div>
        
        
        <!-- applications -->
        
        
                <div id="Applications" class="content-container">
                    <div class="article-title text">
                        <h1>Applications</h1>
                     </div>
                     <br>
                     <hr>
                     <br>
                    <div class="article-title text">
                        <ol>
                            <ul>
                                <li><strong>Routing and Navigation Systems:</strong> Used in GPS systems to calculate the shortest route between locations.
                                    <br>Employed in computer networks for routing data packets efficiently (e.g., OSPF protocol).
                                    </li>
                           <br><br>
                       
                        
                                <li><strong> Telecommunication Networks:</strong>Finds the shortest path in circuit switching and packet-switched networks.
                                    
                                <br>Optimizes network traffic and reduces latency.
        
        
                                </li><br><br>
                        
                                <li><strong>Urban Planning and Traffic Management:</strong> Used for planning road networks and optimizing traffic flow.
                                    <br>Helps determine the shortest route for emergency vehicles.</li>
                            <br><br>
                       
                           
                                <li><strong> Game Development:</strong>Implements pathfinding in games for non-player characters (NPCs) to navigate terrains or mazes.

        
                                </li>
                           <br><br>
                        
                           <li><strong> Robotics and AI:

                           </strong> Guides robotic navigation to find optimal paths while avoiding obstacles.
                           <br>Utilized in autonomous vehicles for route planning.
                           
        
                           </li>
                           <br><br>
                           <li><strong>Infrastructure Planning:</strong> Determines optimal paths for laying cables, pipelines, or power lines.
        
                           </li>
                           <br><br>
                
                        </ul>
                        </ol>
                    
                     </div>
                </div>
        
        
        
                <!-- pseudocode -->
        
                <div id="pseudocode" class="content-container">
                    <div class="article-title text">
                        <h1>Pseudocode</h1>
                     </div>
                     <br>
                     <hr>
                     <br><br>
        <div class="pseudo">
            <div class="article-title text" style="border-radius: 7px; justify-content: center; align-items: center; margin-left: 4px; width: 90%;">
                <h4 style="margin-left: 10px; font-size:15px;font-weight:600">
                    function Dijkstra(Graph, source):<br>
                    &nbsp;&nbsp;&nbsp;&nbsp; dist = [∞ for each node]<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp; dist[source] = 0   <br>   <br> 
                    &nbsp;&nbsp;&nbsp;&nbsp; unvisited = all nodes in Graph<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp; while unvisited is not empty:<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current = node with smallest dist in unvisited<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if dist[current] == ∞: break // Stop if remaining nodes are unreachable<br><br>
            
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor of current:<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alt = dist[current] + weight(current, neighbor)<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if alt < dist[neighbor]:<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist[neighbor] = alt<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove current from unvisited<br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;return dist
                </h4><br>
             </div>
             <div class="article-title text">
                <br>
                <h1>Explanation</h1><br>
                <li><strong> Initialization:</strong> <br>Set all distances to infinity (∞) except for the source node, which is set to 0.
                    <br>Keep track of unvisited nodes.
                </li><br>
                <li><strong> Processing Nodes:</strong> <br>Pick the unvisited node with the smallest distance (current).
                    <br>If the smallest distance is infinity, stop early, as all remaining nodes are unreachable.
                </li><br>
                <li><strong>Relaxation:</strong> <br>For each neighbor of the current node, calculate a tentative distance.
                   <br> If the tentative distance is smaller than the known distance, update it.
                </li><br>
                <li><strong>Mark as Visited:</strong> <br>Remove the current node from the unvisited set once its neighbors are processed.

                 </li><br>
                 <li><strong>Output:

                 </strong> <br>Return the dist array, which contains the shortest distances from the source node to all other nodes.

                 </li><br>
                
            </div>
             <br>
        </div>
                </div>
        
        <!-- flowchart -->
        
        
                <div id="flowchart" class="content-container" style="height: auto;">
                    <div class="article-title text">
                        <h1>Flowchart</h1>
                     </div>
                     <br>
                     <hr>
                     <img src="img/insertion_sort.png" alt="AlgoVerse Logo" class="logo" style="width: 500px; /* Specify the width of the image */
                     height: 500px; /* Maintain aspect ratio */
                     border-radius: 5px;
                     box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                     margin-top: 30px;">
                     <br><br>
        
         
                </div>
        
         
        
              
                <!-- visualization -->
        
        
                <div id="Visualization" class="content-container">
                    <div class="article-title text">
                        <h1>Visualization</h1>
                     </div>
                     <hr>
                     <div class="cancel" onclick="normalscreen()"><i class="fa-solid fa-xmark"></i></div>
                     <div class="container">
                        <div class="graph">
                            <div class="node" id="node0" style="top: 80px; left: 20px;">0</div>
                            <div class="node" id="node1" style="top: 150px; left: 100px;">1</div>
                            <div class="node" id="node2" style="top: 10px; left: 100px;">2</div>
                            <div class="node" id="node3" style="top: 80px; left: 180px;">3</div>
                            <div class="node" id="node4" style="top: 10px; left: 260px;">4</div>
                            <div class="node" id="node6" style="top: 80px; left: 350px;">6</div>
                            <div class="node" id="node5" style="top: 150px; left: 260px;">5</div>
                            <div class="edge" data-start="0" data-end="2" style="top: 60px; left: 40px; width: 70px;transform:rotate(137deg);width:75px;height:3px;border-radius:2px;"><span style="color:black;margin-top:15px;">6</span></div>
                            <div class="edge" data-start="0" data-end="1" style="top: 129px; left: 42px; height: 3px;border-radius:5px;width:76px;transform:rotate(220deg)"><span style="color:black;margin-top:-15px;">2</span></div>
                            <div class="edge" data-start="2" data-end="3" style="top: 58px; left: 121px; height: 3px;width:75px;transform:rotate(40deg);border-radius:3px;"><span style="color:black;margin-top:-15px;">8</span></div>
                            <div class="edge" data-start="1" data-end="3" style="top: 130px; left: 118px;height:3px; width: 76px;transform:rotate(140deg);border-radius:5px;"><span style="color:black;margin-top:-15px;">5</span></div>
                            <div class="edge" data-start="2" data-end="4" style="top: 60px; left: 200px; width: 73px;height:3px;transform:rotate(318deg);border-radius:5px;"><span style="color:black;margin-top:-15px;">10</span></div>
                            <div class="edge" data-start="4" data-end="6" style="top: 59px; left: 282px; height: 3px; width:82px;transform:rotate(40deg);border-radius:5px;"><span style="color:black;margin-top:-15px;">2</span></div>
                            <div class="edge" data-start="3" data-end="5" style="top: 130px; left: 200px; width: 75px;height:3px;transform:rotate(220deg);border-radius:5px;"><span style="color:black;margin-top:-15px;">15</span></div>
                    
                            <div class="edge" data-start="5" data-end="6" style="top: 130px; left: 280px; height: 3px;width:82px;transform:rotate(140deg);border-radius:5px;"><span style="color:black;margin-top:-15px;">6</span></div>
                        </div>
                        <div class="info">
                                  <div class="vertex-info"> </div> 
                        </div>
                    </div>
                     
                     <div class="screen" onclick="fullscreen()"><i class="fa-solid fa-expand"></i></div>

                    <div class="prompt">
                        <div class="box-1">
                            <button id="startButton">Start</button>
                            <button id="resetButton" disabled>Reset</button>
                        </div>          
                    </div>
                    
                </div>
                <div id="tcomplexity" class="content-container">
                    <div class="article-title text">
                        <h1>Complexity</h1>
                        <hr><br>
                    </div>
                    <div id="complexity-analysis">
                        <!-- This will display time and space complexity -->
                    </div>
                </div>
                <div id="Explaination" class="content-container">
                    <div class="article-title text">
                        <h1>Visualization Explanation</h1>
                        <hr><br>
                        <div id="Explain">
                        </div>
                    </div>
                </div>
        <!-- time complexity -->
                <div id="complexity" class="content-container">
                    <div>
                        <h4>Time Complexity </h4>
                        <hr>
                        <h4>Best Case</h4>
                        <p>
                            <strong>Scenario:</strong><br>
                            A sparse graph with minimal edges (<i>E ≈ V</i>).<br>
                            Distance updates (relaxations) rarely occur because the graph has well-distributed edge weights and paths are already shortest.
                        </p>
                        <p>
                            <strong>Complexity:</strong><br>
                            Extracting the minimum distance vertex: <code>O(V log V)</code>.<br>
                            Relaxing all edges: <code>O(E log V)</code>.<br>
                            Total Complexity: <code>O((V + E) log V) ≈ O(V log V)</code>.
                        </p>
                        
                        <h4>Average Case</h4>
                        <p>
                            <strong>Scenario:</strong><br>
                            A typical scenario where the graph is neither very sparse nor very dense.<br>
                            Relaxations occur for a reasonable proportion of edges, depending on edge weights and graph connectivity.
                        </p>
                        <p>
                            <strong>Complexity:</strong><br>
                            Extracting the minimum distance vertex: <code>O(V log V)</code>.<br>
                            Relaxing edges proportional to <i>E</i>: <code>O(E log V)</code>.<br>
                            Total Complexity: <code>O((V + E) log V)</code>.
                        </p>
                        
                        <h4>Worst Case</h4>
                        <p>
                            <strong>Scenario:</strong><br>
                            A dense graph with maximum edges (<i>E ≈ V<sup>2</sup></i>).<br>
                            Every edge contributes to relaxations, leading to more priority queue operations.<br>
                            The graph is highly connected, requiring frequent updates to the heap.
                        </p>
                        <p>
                            <strong>Complexity:</strong><br>
                            Extracting the minimum distance vertex: <code>O(V log V)</code>.<br>
                            Relaxing <i>E</i> edges: <code>O(E log V)</code>.<br>
                            Total Complexity: <code>O((V + E) log V) ≈ O(V<sup>2</sup> log V)</code>.
                        </p>
                    </div>
                    
             </div>
        
        
        
        <!-- space compleity -->
        
                <div id="scomplexity" class="content-container">
                    <div>
                        <h4>Space Complexity</h4>
                        <hr>
                        <h4>Best Case</h4>
                        <p>
                            <strong>Scenario:</strong><br>
                            In the best case, the space complexity is determined by the data structures used, like the priority queue, distance array, and the graph representation.
                        </p>
                        <p>
                            <strong>Complexity:</strong><br>
                            The space required for the graph (adjacency list or matrix) is <code>O(E + V)</code>, where <i>E</i> is the number of edges and <i>V</i> is the number of vertices.<br>
                            The priority queue also requires <code>O(V)</code> space to store all vertices in the worst case.<br>
                            The distance array and visited list require <code>O(V)</code> space each.<br>
                            Total Space Complexity: <code>O(E + V)</code>.
                        </p>
                        
                        <h4>Average Case</h4>
                        <p>
                            <strong>Scenario:</strong><br>
                            In the average case, the space complexity remains similar to the best case, since the algorithm's space usage is largely determined by the number of vertices and edges, and the data structures used.
                        </p>
                        <p>
                            <strong>Complexity:</strong><br>
                            The space for storing the graph and the priority queue is <code>O(E + V)</code>, and the space for the distance array and visited list remains <code>O(V)</code>.<br>
                            Total Space Complexity: <code>O(E + V)</code>.
                        </p>
                        
                        <h4>Worst Case</h4>
                        <p>
                            <strong>Scenario:</strong><br>
                            In the worst case, the space complexity is still determined by the size of the graph, priority queue, and the arrays used to store distances and visited nodes. The algorithm may need to store all vertices in the priority queue and distance arrays.
                        </p>
                        <p>
                            <strong>Complexity:</strong><br>
                            The space required to store the graph and priority queue is <code>O(E + V)</code>, and the distance array and visited list are <code>O(V)</code>.<br>
                            Total Space Complexity: <code>O(E + V)</code>.
                        </p>
                    </div>
            </div>



<!-- script -->

<script >
    function openSidebar() {
        const sidebar = document.getElementById('sidebar');
        const menuBtn = document.querySelector('.menu-btn');
    
        sidebar.style.width = '280px'; // Set the sidebar width to its full size
        sidebar.style.transform = 'translateX(0)'; // Slide the sidebar into view
        menuBtn.style.display = 'none'; // Hide the menu button
    }
    function closeSidebar() {
        const sidebar = document.getElementById('sidebar');
        const menuBtn = document.querySelector('.menu-btn');
    
        sidebar.style.transform = 'translateX(-100%)'; // Slide the sidebar out of view
        menuBtn.style.display = 'flex'; // Show the menu button
    }
    

function toggleSubmenu1() {
const submenu = document.getElementById("submenu1");
submenu.classList.toggle("expanded");
const arrowIcon = document.querySelector(".arrow-icon");
arrowIcon.style.transform = submenu.classList.contains("expanded") ? "rotate(180deg)" : "rotate(0deg)";
}
function toggleSubmenu2() {
const submenu = document.getElementById("submenu2");
submenu.classList.toggle("expanded");
const arrowIcon = document.querySelector(".arrow-icon2");
arrowIcon.style.transform = submenu.classList.contains("expanded") ? "rotate(180deg)" : "rotate(0deg)";
}



document.addEventListener('DOMContentLoaded', function() {
const sidebar = document.querySelector('.sidebar');

sidebar.addEventListener('click', function(e) {
    if (e.target.tagName === 'A' && e.target.getAttribute('href').startsWith('#')) {
        e.preventDefault();
        
        const targetId = e.target.getAttribute('href');
        const targetElement = document.querySelector(targetId);
        
        if (targetElement) {
            // Quickly scroll to the target element
            window.scrollTo({
                top: targetElement.offsetTop - 100, // Adjust for fixed header
                behavior: 'auto' // No smooth scrolling, immediate jump
            });

            // Update active link immediately
            document.querySelectorAll('.sidebar a').forEach(link => link.classList.remove('active'));
            e.target.classList.add('active');
        }
    }
});
});


window.onload = function() {
document.getElementById("Visualization").scrollIntoView();
};

</script>
<script src="diji.js"></script>
 <!-- Bootstrap JS and dependencies -->
 <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
 <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
 <script src="js/index2.js"></script>
 <script>
    function handleStepActivation(selector, stepClass) {
        document.querySelectorAll(selector + ' .step a').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault(); // Prevent default anchor behavior
                
                // Find the index of the clicked step
                const clickedStepIndex = Array.from(this.closest('.step').parentNode.children).indexOf(this.closest('.step'));
                // Reset all steps to default state
                document.querySelectorAll(selector + ' .step').forEach((step, index) => {
                    if (index < clickedStepIndex) {
                        step.classList.add('active');
                        step.querySelector('.line').style.backgroundColor = '#007bff';
                    } else if (index === clickedStepIndex) {
                        step.classList.add('active');
                        step.querySelector('.line').style.backgroundColor = '#d3d3d3'; // Keep the line color of the clicked step default
                    } else {
                        step.classList.remove('active');
                        step.querySelector('.line').style.backgroundColor = '#d3d3d3';
                    }
                });
            });
        });
    }

    // Handle steps for Description submenu
    handleStepActivation('.has-submenu .step-indicator', 'step');

    // Handle steps for Algorithm submenu
    handleStepActivation('.has-submenu .step-indicator2', 'step');
 </script>
</body>
</html>
